#version 450

// ------------ Struct definitions --------------
struct Camera{
    mat4 view;
    mat4 viewInv;
    mat4 proj;
    mat4 projInv;
    mat4 viewproj;
    vec3 position;
    float tanHalfFOV;
};

struct Ray{
    vec3 orig;
    vec3 dir;
};

struct Interval{
    float minV;
    float maxV;
};

struct Sphere{
    vec3 pos; // Coordinates of the center
    float r; // Radius
};

struct Hit{
    vec3 p; // Where it happend
    vec3 normal; // The normal where it hit
    float t; // The distance from the ray origin to the hit
    bool frontFace; // True if hit is to a front facing surface
};

// ------------ Constant definitions --------------
const int rays_per_pixel = 100;

const float pInf = 1.0 / 0.0;
const float nInf = -1.0 / 0.0;
const Interval empty_interval = Interval(pInf, nInf);
const Interval universe_interval = Interval(nInf, pInf);

// ------------ External memory layout --------------
layout(set = 0, binding = 0) uniform UniformBufferObject {
    Camera camera;
} ubo;

layout(set = 1, binding = 0, rgba8) uniform writeonly image2D outputImage;

layout(set = 1, std140, binding = 1) buffer ParticleSSBOOut {
    Sphere spheres[];
};

// ------------ Workgroup sizes --------------
layout(local_size_x = 16, local_size_y = 16) in;

// Global variables
ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
ivec2 imageSize = imageSize(outputImage);
float aspectRatio = float(imageSize.x)/float(imageSize.y);

uint seed;


// ------------ RNG functions --------------

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

uint xorshift(inout uint state) {
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float random() {
    return float(xorshift(seed)) / 4294967295.0; // Dividir por 2^32 - 1
}

vec2 sample_square(){
    return vec2(random()-0.5,random()-0.5);
}


// ------------ Ray functions --------------
// Having the length of a hit (t) returns the point where it hit
vec3 at(const Ray r, const float t){
    return r.orig + t*r.dir;
}

// ------------ Interval functions --------------
bool contains(Interval i, float x){
    return i.minV <= x && i.maxV >= x;
}
bool surrounds(Interval i, float x){
    return i.minV < x && i.maxV > x;
}
float clamp(Interval i, float x){
    if(x < i.minV) return i.minV; 
    if(x > i.maxV) return i.maxV;
    return x;
}

// ------------ Hit record functions --------------
// Having the outward facing normal of the surface hit
// updates the record frontFace and normal to correct values
void set_face_normal(inout Hit h, const Ray r, const vec3 outward_normal){
    h.frontFace = dot(r.dir,outward_normal) < 0;
    if(h.frontFace){
        h.normal = outward_normal;
    }else{
        h.normal = -outward_normal;
    }
}

// ------------ Spheres functions --------------
// Returns true if the ray colides with the sphere
// If it hits it fills out th hit record
bool hit_sphere(const Sphere s, const Interval ray_t, const Ray r, out Hit rec){
    vec3 oc = s.pos - r.orig;
    float a = dot(r.dir,r.dir);
    float h = dot(r.dir, oc);
    float c = dot(oc,oc) - s.r*s.r;
    float discriminant = h*h - a*c;
    if (discriminant < 0) {
        return false;
    } 

    float srtd = sqrt(discriminant);

    float root = (h - srtd) / a;
    if(!surrounds(ray_t,root)){
        root = (h + srtd) / a;
        if(!surrounds(ray_t,root)){
            return false;
        }
    }

    rec.t = root;
    rec.p = at(r,root);
    vec3 outward_normal = (rec.p - s.pos) / s.r;
    set_face_normal(rec, r, outward_normal);

    return true;
}

// ------------ Scene functions --------------
// Calculates the hit record for the ray
// ray_tmin and ray_tmax to be investigated
bool hit_scene(const Ray r, const Interval ray_t, inout Hit rec){
    Hit temp_rec;
    bool hit_anything = false;
    float closest_so_far = ray_t.maxV;

    // For every sphere in the scene
    for(int i = 0; i< spheres.length(); i++){
        if(hit_sphere(spheres[i],ray_t,r,temp_rec)){
            hit_anything = true;
            if(closest_so_far > temp_rec.t){
                closest_so_far = temp_rec.t;
                rec = temp_rec;
            }
        }
    }

    return hit_anything;
}

// Calculates the color of the ray by tracing it with the scene
vec4 ray_color(Ray r){
    Hit h;
    if(hit_scene(r,Interval(0,pInf),h)){
        if(!h.frontFace) return vec4(1.0,1.0,1.0,1.0);
        return vec4((h.normal + vec3(1.0,1.0,1.0))* 0.5,1.0);
    }

    vec3 dir_unit = normalize(r.dir);
    float a = 0.5*(dir_unit.y + 1.0);
    return (1.0-a)*vec4(0.286, 0.365, 0.631, 1.0) + a*vec4(1.0, 1.0, 1.0, 1.0);
}

Ray get_ray(){
    vec2 pixelCoordsOffset = pixelCoords + sample_square();

    float ndcX = 2.0 * pixelCoordsOffset.x / imageSize.x - 1.0;
    float ndcY = 1.0 - 2.0 * pixelCoordsOffset.y / imageSize.y;

    vec3 rayDirCameraSpace = normalize(vec3(
        ndcX * aspectRatio * ubo.camera.tanHalfFOV,
        ndcY * ubo.camera.tanHalfFOV,
        -1.0
    ));

    vec3 rayDir = normalize(vec3(ubo.camera.viewInv * vec4(rayDirCameraSpace, 0.0)));

    // Ray of the pixel asigned
    Ray ray;
    ray.orig = ubo.camera.position;
    ray.dir = rayDir;

    return ray;
}



void main() {
    // RNG seed, will change after each generation of number
    // Deterministic based on camera pos and dir
    // Probably good enough ... I think
    seed = hash(floatBitsToUint(ubo.camera.view[0][0])) 
          ^ hash(floatBitsToUint(ubo.camera.view[1][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[2][2])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][2])) 
          ^ hash(uint(pixelCoords.x + pixelCoords.y * 1920));

    

    vec4 color = vec4(0.0,0.0,0.0,0.0);
    Ray ray;

    for(int i = 0; i < rays_per_pixel; i++){
        ray = get_ray();
        color += ray_color(ray);
    }

    // Calculate color of pixel
    color = color/rays_per_pixel;
    //color = normalize(vec4(random(),random(),random(),0.0)); // Visual rng test
    color.w = 1.0; // Solid, no transparency... yet 
    
    // Store color
    imageStore(outputImage, pixelCoords, color.zyxw);
}