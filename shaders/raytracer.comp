#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

#define PI 3.14159265359
#define FLT_MIN 1.175494e-38
#define AIR_REF_INDEX 1.000293

#define LAMBERTIAN 1
#define METAL      2
#define DIFFUSE    3
#define DIELECTRIC 4

// ------------ Struct definitions --------------
struct Camera{
    mat4 view;
    mat4 viewInv;
    mat4 proj;
    mat4 projInv;
    mat4 viewproj;
    vec3 position;
    float tanHalfFOV;
};

struct Ray{
    vec3 orig;
    vec3 dir;
};

struct Interval{
    float minV;
    float maxV;
};

struct Material{
    vec3 albedo;
    float aux1;
    int function;
};

struct Sphere{
    vec3 pos; // Coordinates of the center
    float r; // Radius
    int mat; // Material index
};

struct Hit{
    vec3 p; // Where it happend
    vec3 normal; // The normal where it hit
    int mat; // Material index of the object it hit
    float t; // The distance from the ray origin to the hit
    bool frontFace; // True if hit is to a front facing surface
};

// ------------ Constant definitions --------------
const int rays_per_pixel = 20;
const int max_bounces = 20;


const float PINF = 1.0 / 0.0;
const float NINF = -1.0 / 0.0;
const Interval empty_interval = Interval(PINF, NINF);
const Interval universe_interval = Interval(NINF, PINF);

// ------------ External memory layout --------------
layout(set = 0, binding = 0) uniform UniformBufferObject {
    Camera camera;
    float time;
    uint frameCount;
} ubo;

layout(set = 1, binding = 0, rgba8) uniform writeonly image2D outputImage;

layout(set = 1, std430, binding = 1) buffer SpheresSSBOOut {
    Sphere spheres[];
};

layout(set = 1, std430, binding = 2) buffer MaterialsSSBOOut {
    Material materials[];
};

// ------------ Workgroup sizes --------------
layout(local_size_x = 32, local_size_y = 32) in;

// Global variables
ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
ivec2 imageSize = imageSize(outputImage);
float aspectRatio = float(imageSize.x)/float(imageSize.y);

uint seed;


// ------------ RNG functions --------------

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

uint xorshift(inout uint state) {
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float random(){
    return float(xorshift(seed)) / 4294967295.0; // Dividir por 2^32 - 1
}

float random_bound(float minV, float maxV){
    return minV + (maxV-minV)*random();
}

vec3 randomVec(){
    return vec3(random(),random(),random());
}

vec3 random_vec_bound(float minV, float maxV){
    return vec3(random_bound(minV,maxV),random_bound(minV,maxV),random_bound(minV,maxV));
}

vec3 random_unit_vec(){
    float phi = 2.0 * PI * random();
    float theta = acos(2.0 * random() - 1.0);
    float sin_theta = sin(theta);
    return vec3(
        sin_theta * cos(phi),
        sin_theta * sin(phi),
        cos(theta)
    );
}

vec3 random_vec_on_hemisphere(vec3 normal){
    vec3 rvec = random_unit_vec();
    if(dot(rvec,normal) > 0.0){
        return rvec;
    }else{
        return -rvec;
    }
}

vec2 sample_square(){
    return vec2(random()-0.5,random()-0.5);
}

// ------------ vec3 functions --------------
bool near_zero(const vec3 v){
    return (FLT_MIN > v.x) && (FLT_MIN > v.y) && (FLT_MIN > v.z);
}


// ------------ Ray functions --------------
// Having the length of a hit (t) returns the point where it hit
vec3 at(const Ray r, const float t){
    return r.orig + t*r.dir;
}


// ------------ Interval functions --------------
bool contains(Interval i, float x){
    return i.minV <= x && i.maxV >= x;
}
bool surrounds(Interval i, float x){
    return i.minV < x && i.maxV > x;
}
float clamp_interval(Interval i, float x){
    if(x < i.minV) return i.minV; 
    if(x > i.maxV) return i.maxV;
    return x;
}

// ------------ Hit record functions --------------
// Having the outward facing normal of the surface hit
// updates the record frontFace and normal to correct values
void set_face_normal(inout Hit h, const Ray r, const vec3 outward_normal){
    h.frontFace = dot(r.dir,outward_normal) < 0;
    if(h.frontFace){
        h.normal = outward_normal;
    }else{
        h.normal = -outward_normal;
    }
}

// ------------ Spheres functions --------------
// Returns true if the ray colides with the sphere
// If it hits it fills out th hit record
bool hit_sphere(const Sphere s, const Interval ray_t, const Ray r, out Hit rec){
    vec3 oc = s.pos - r.orig;
    float a = dot(r.dir,r.dir);
    float h = dot(r.dir, oc);
    float c = dot(oc,oc) - s.r*s.r;
    float discriminant = h*h - a*c;
    if (discriminant < 0) {
        return false;
    } 

    float srtd = sqrt(discriminant);

    float root = (h - srtd) / a;
    if(!surrounds(ray_t,root)){
        root = (h + srtd) / a;
        if(!surrounds(ray_t,root)){
            return false;
        }
    }

    rec.t = root;
    rec.p = at(r,root);
    rec.mat = s.mat;
    vec3 outward_normal = (rec.p - s.pos) / s.r;
    set_face_normal(rec, r, outward_normal);

    return true;
}

// ------------ Material functions --------------
bool scatter_lambertian(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    vec3 bounce_dir = rec.normal + random_vec_on_hemisphere(rec.normal);
    //if(near_zero(bounce_dir)) bounce_dir = rec.normal;
    scattered = Ray(rec.p, bounce_dir);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}

// aux1 = fuzzines
bool scatter_metal(const Hit rec, out vec4 attenuation, in Ray ray_in,out Ray scattered){
    vec3 reflected = reflect(ray_in.dir,rec.normal) + random_unit_vec() * materials[rec.mat].aux1;
    scattered = Ray(rec.p, reflected);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}

bool scatter_diffuse(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    vec3 bounce_dir = random_vec_on_hemisphere(rec.normal);
    scattered = Ray(rec.p, bounce_dir);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}

// Fresnel-Schlick aproximation to reflectance
float reflectance(float cosine, float ref_idx) {
    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
}

// aux1 = refraction index
bool scatter_dielectric(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    attenuation = vec4(1.0);
    float eta = rec.frontFace ? (AIR_REF_INDEX / materials[rec.mat].aux1) 
                             : (materials[rec.mat].aux1 / AIR_REF_INDEX);
    
    vec3 unit_direction = normalize(ray_in.dir);
    
    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);
    
    bool cannot_refract = eta * sin_theta > 1.0;
    vec3 direction;
    
    if (cannot_refract || reflectance(cos_theta,eta) > random()) {
        // Reflexión interna total
        direction = reflect(unit_direction, rec.normal);
    } else {
        // Refracción con posible reflexión de Fresnel
        direction = refract(unit_direction, rec.normal, eta);
    }
    
    scattered = Ray(rec.p, direction);
    return true;
}

// Generic scatter function for materials
bool scatter(int material, const Hit rec, out vec4 attenuation, in Ray ray_in,out Ray scattered){
    switch(materials[rec.mat].function){
        case LAMBERTIAN: return scatter_lambertian(rec,attenuation,ray_in,scattered);
        case METAL: return scatter_metal(rec,attenuation,ray_in,scattered);
        case DIFFUSE: return scatter_diffuse(rec,attenuation,ray_in,scattered);
        case DIELECTRIC: return scatter_dielectric(rec,attenuation,ray_in,scattered);
    }
    return false;
}




// ------------ Scene functions --------------
// Calculates the hit record for the ray
// ray_tmin and ray_tmax to be investigated
bool hit_scene(const Ray r, const Interval ray_t, inout Hit rec){
    Hit temp_rec;
    bool hit_anything = false;
    float closest_so_far = ray_t.maxV;

    // For every sphere in the scene
    for(int i = 0; i< spheres.length(); i++){
        if(hit_sphere(spheres[i],ray_t,r,temp_rec)){
            hit_anything = true;
            if(closest_so_far > temp_rec.t){
                closest_so_far = temp_rec.t;
                rec = temp_rec;
            }
        }
    }

    return hit_anything;
}

// Color of the skybox where the ray is pointing to
vec4 skybox_color(Ray r){
    vec3 dir_unit = normalize(r.dir);
    float a = 0.5 * (dir_unit.y + 1.0);
    return (1.0 - a) * vec4(1.0, 1.0, 1.0, 1.0) + a * vec4(0.286, 0.365, 0.631, 1.0);
}

// Calculates the color of the ray by tracing it with the scene
vec4 ray_color(Ray r){
    vec4 accumulated_color = vec4(1.0); 
    Ray current_ray = r;
    
    for (int bounce = 0; bounce < max_bounces; bounce++) {
        Hit h;
        if (hit_scene(current_ray, Interval(0.005, PINF), h)) {
            //return 0.5 * (vec4(h.normal,0.0)+vec4(1.0)); // Normal vector colors
            Ray scattered;
            vec4 attenuation;
            if(scatter(h.mat,h,attenuation,current_ray,scattered)){
                current_ray = scattered;
                accumulated_color *= attenuation;
            }else{
                // Material not found color
                return vec4(0.984, 0.224, 1.0, 1.0);
            }
            
        } else {
            return accumulated_color * skybox_color(r);
        }
    }
    
    return vec4(0.0);
}

// Generates a ray pointing to the pixel this thread is assign with a random half-pixel (square) offset
Ray get_ray(){
    vec2 pixelCoordsOffset = pixelCoords + sample_square();

    float ndcX = 2.0 * pixelCoordsOffset.x / imageSize.x - 1.0;
    float ndcY = 1.0 - 2.0 * pixelCoordsOffset.y / imageSize.y;

    vec3 rayDirCameraSpace = normalize(vec3(
        ndcX * aspectRatio * ubo.camera.tanHalfFOV,
        ndcY * ubo.camera.tanHalfFOV,
        -1.0
    ));

    vec3 rayDir = normalize(vec3(ubo.camera.viewInv * vec4(rayDirCameraSpace, 0.0)));

    Ray ray;
    ray.orig = ubo.camera.position;
    ray.dir = rayDir;

    return ray;
}



void main() {

    // RNG seed, will change after each generation of number
    seed = hash(uint(ubo.time)*1920) 
            ^ hash(ubo.frameCount)
            ^ hash(uint(pixelCoords.x + pixelCoords.y * 1920));
    /*hash(floatBitsToUint(ubo.camera.view[0][0])) 
          ^ hash(floatBitsToUint(ubo.camera.view[1][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[2][2])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][2])) 
    */

    vec4 color = vec4(0.0);
    Ray ray;

    for(int i = 0; i < rays_per_pixel; i++){
        ray = get_ray();
        color += ray_color(ray);
    }

    // Calculate color of pixel
    color = color/rays_per_pixel;
    //color = normalize(vec4(random(),random(),random(),0.0)); // Visual rng test
    color = vec4(pow(color.xyz, vec3(1.0/2.2)), 1.0);
    
    // Store color
    imageStore(outputImage, pixelCoords, color.zyxw);
}