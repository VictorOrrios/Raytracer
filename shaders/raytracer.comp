#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

#define PI 3.14159265359
#define FLT_MIN 1.175494e-38
#define AIR_REF_INDEX 1.000293

#define DIFFUSE         1
#define METAL           2
#define TRANSMISSIVE    3
#define SUBSURFACE      4
#define EMITER          5


// ------------ Struct definitions --------------
struct Camera{
    mat4 view;
    mat4 viewInv;
    mat4 proj;
    mat4 projInv;
    mat4 viewproj;
    vec3 position;
    float tanHalfFOV;
};

struct Ray{
    vec3 orig;
    vec3 dir;
};

struct Interval{
    float minV;
    float maxV;
};

struct Material{
    vec4 albedo; // Base color rgb
    vec4 emission_color; // Rgb color of emited light, 0.0 for non emited
    vec4 transmission_subsurface_color; // Shared rgb color for transmision or subsurface scattering
    float metalness; // 0.0 = dielectric , 1.0 = metalic
    float roughness; // 0.0 = smooth , 1.0 = rough
    float opacity_subsurface_strength; // opacity: 0.0 = transparent, 1.0 = opaque || subsurface strength: intensity of dispersion
    float ior; // Index of refraction
    int type; // Flag to know what type of material is this
};

struct Sphere{
    vec3 pos; // Coordinates of the center
    float r; // Radius
    int mat; // Material index
};

struct Hit{
    vec3 p; // Where it happend
    vec3 normal; // The normal where it hit
    int mat; // Material index of the object it hit
    float t; // The distance from the ray origin to the hit
    bool frontFace; // True if hit is to a front facing surface
};

// ------------ Constant definitions --------------
const int rays_per_pixel = 20;
const int max_bounces = 20;


const float PINF = 1.0 / 0.0;
const float NINF = -1.0 / 0.0;
const Interval empty_interval = Interval(PINF, NINF);
const Interval universe_interval = Interval(NINF, PINF);

// ------------ External memory layout --------------
layout(set = 0, binding = 0) uniform UniformBufferObject {
    Camera camera;
    float time;
    uint frameCount;
} ubo;

layout(set = 1, binding = 0, rgba8) uniform writeonly image2D outputImage;

layout(set = 1, std430, binding = 1) buffer SpheresSSBOOut {
    Sphere spheres[];
};

layout(set = 1, std430, binding = 2) buffer MaterialsSSBOOut {
    Material materials[];
};

// ------------ Workgroup sizes --------------
layout(local_size_x = 32, local_size_y = 32) in;

// Global variables
ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
ivec2 imageSize = imageSize(outputImage);
float aspectRatio = float(imageSize.x)/float(imageSize.y);

uint seed;


// ------------ RNG functions --------------

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

uint xorshift(inout uint state) {
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float random(){
    return float(xorshift(seed)) / 4294967295.0; // Dividir por 2^32 - 1
}

float random_bound(float minV, float maxV){
    return minV + (maxV-minV)*random();
}

vec3 randomVec(){
    return vec3(random(),random(),random());
}

vec3 random_vec_bound(float minV, float maxV){
    return vec3(random_bound(minV,maxV),random_bound(minV,maxV),random_bound(minV,maxV));
}

vec3 random_unit_vec(){
    float phi = 2.0 * PI * random();
    float theta = acos(2.0 * random() - 1.0);
    float sin_theta = sin(theta);
    return vec3(
        sin_theta * cos(phi),
        sin_theta * sin(phi),
        cos(theta)
    );
}

vec3 random_vec_on_hemisphere(vec3 normal){
    vec3 rvec = random_unit_vec();
    if(dot(rvec,normal) > 0.0){
        return rvec;
    }else{
        return -rvec;
    }
}

vec2 sample_square(){
    return vec2(random()-0.5,random()-0.5);
}

// ------------ vec3 functions --------------
bool near_zero(const vec3 v){
    return (FLT_MIN > v.x) && (FLT_MIN > v.y) && (FLT_MIN > v.z);
}


// ------------ Ray functions --------------
// Having the length of a hit (t) returns the point where it hit
vec3 at(const Ray r, const float t){
    return r.orig + t*r.dir;
}


// ------------ Interval functions --------------
bool contains(Interval i, float x){
    return i.minV <= x && i.maxV >= x;
}
bool surrounds(Interval i, float x){
    return i.minV < x && i.maxV > x;
}
float clamp_interval(Interval i, float x){
    if(x < i.minV) return i.minV; 
    if(x > i.maxV) return i.maxV;
    return x;
}

// ------------ Hit record functions --------------
// Having the outward facing normal of the surface hit
// updates the record frontFace and normal to correct values
void set_face_normal(inout Hit h, const Ray r, const vec3 outward_normal){
    h.frontFace = dot(r.dir,outward_normal) < 0;
    if(h.frontFace){
        h.normal = outward_normal;
    }else{
        h.normal = -outward_normal;
    }
}

// ------------ Spheres functions --------------
// Returns true if the ray colides with the sphere
// If it hits it fills out th hit record
bool hit_sphere(const Sphere s, const Interval ray_t, const Ray r, out Hit rec){
    vec3 oc = s.pos - r.orig;
    float a = dot(r.dir,r.dir);
    float h = dot(r.dir, oc);
    float c = dot(oc,oc) - s.r*s.r;
    float discriminant = h*h - a*c;
    if (discriminant < 0) {
        return false;
    } 

    float srtd = sqrt(discriminant);

    float root = (h - srtd) / a;
    if(!surrounds(ray_t,root)){
        root = (h + srtd) / a;
        if(!surrounds(ray_t,root)){
            return false;
        }
    }

    rec.t = root;
    rec.p = at(r,root);
    rec.mat = s.mat;
    vec3 outward_normal = (rec.p - s.pos) / s.r;
    set_face_normal(rec, r, outward_normal);

    return true;
}

// ------------ Material functions --------------
/*
bool scatter_lambertian(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    vec3 bounce_dir = normalize(rec.normal + random_vec_on_hemisphere(rec.normal));
    //if(near_zero(bounce_dir)) bounce_dir = rec.normal;
    scattered = Ray(rec.p, bounce_dir);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}

// aux1 = fuzzines
bool scatter_metal(const Hit rec, out vec4 attenuation, in Ray ray_in,out Ray scattered){
    vec3 reflected = normalize(reflect(ray_in.dir,rec.normal) + random_unit_vec() * materials[rec.mat].aux1);
    scattered = Ray(rec.p, reflected);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}

bool scatter_diffuse(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    vec3 bounce_dir = random_vec_on_hemisphere(rec.normal);
    scattered = Ray(rec.p, bounce_dir);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}


// aux1 = refraction index
bool scatter_dielectric(const Hit rec, out vec4 attenuation, in Ray ray_in, out Ray scattered){
    attenuation = vec4(1.0);
    float eta = rec.frontFace ? (AIR_REF_INDEX / materials[rec.mat].aux1) 
                             : (materials[rec.mat].aux1 / AIR_REF_INDEX);
    
    vec3 unit_direction = normalize(ray_in.dir);
    
    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);
    
    bool cannot_refract = eta * sin_theta > 1.0;
    vec3 direction;
    
    if (cannot_refract || reflectance(cos_theta,eta) > random()) {
        // Reflexión interna total
        direction = reflect(unit_direction, rec.normal);
    } else {
        // Refracción con posible reflexión de Fresnel
        direction = refract(unit_direction, rec.normal, eta);
    }
    
    scattered = Ray(rec.p, direction);
    return true;
}

bool scatter_specular(const Hit rec, out vec4 attenuation, in Ray ray_in,out Ray scattered){
    vec3 reflected = normalize(reflect(ray_in.dir,rec.normal)/materials[rec.mat].aux1 + random_unit_vec() * materials[rec.mat].aux1);
    scattered = Ray(rec.p, reflected);
    attenuation = vec4(materials[rec.mat].albedo,1.0);
    return true;
}
*/

// Fresnel-Schlick aproximation to reflectance
float reflectance(float cosine, float ref_idx) {
    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
}



// Generic scatter function for materials
bool scatter(const Hit rec, inout Ray ray, inout vec4 ray_color, inout vec4 incoming_light){
    Material mat = materials[rec.mat];

    // Light emiter
    if(mat.type == EMITER){
        incoming_light += mat.emission_color * ray_color;
        return false; // No scattering on lights
    }

    vec3 scatter_direction;


    switch(mat.type){
        case DIFFUSE:
            scatter_direction = normalize(rec.normal + random_vec_on_hemisphere(rec.normal));
            //if(near_zero(bounce_dir)) bounce_dir = rec.normal;
            ray_color *= mat.albedo;
            break;

        case METAL:
            scatter_direction = normalize(reflect(ray.dir,rec.normal) + random_vec_on_hemisphere(rec.normal) * mat.roughness);
            ray_color *= mix(vec4(1.0), mat.albedo, mat.metalness);
            break;

        case TRANSMISSIVE:
            float ref_ratio = rec.frontFace ? (AIR_REF_INDEX / mat.ior) 
                                            : (mat.ior / AIR_REF_INDEX);
    
            vec3 unit_direction = normalize(ray.dir);
            
            float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
            float sin_theta = sqrt(1.0 - cos_theta*cos_theta);
            
            bool cannot_refract = ref_ratio * sin_theta > 1.0;
            vec3 direction;
            
            if (cannot_refract || reflectance(cos_theta, ref_ratio) > random()) {
                scatter_direction = reflect(unit_direction, rec.normal);
            } else {
                scatter_direction = refract(unit_direction, rec.normal, ref_ratio);
            }

            if (mat.opacity_subsurface_strength < 1.0) {
                ray_color *= mat.transmission_subsurface_color;
            }

            break;

        case SUBSURFACE:
            // TODO - fix this
            scatter_direction = normalize(rec.normal + mat.opacity_subsurface_strength * random_vec_on_hemisphere(rec.normal));
            ray_color *= mat.transmission_subsurface_color;
            break;

        default:
            // Material type unknown
            return false;
            break;
    }

    ray.orig = rec.p;
    ray.dir = scatter_direction;
    
    return true;
}




// ------------ Scene functions --------------
// Calculates the hit record for the ray
// ray_tmin and ray_tmax to be investigated
bool hit_scene(const Ray r, const Interval ray_t, inout Hit rec){
    Hit temp_rec;
    bool hit_anything = false;
    float closest_so_far = ray_t.maxV;

    // For every sphere in the scene
    for(int i = 0; i< spheres.length(); i++){
        if(hit_sphere(spheres[i],ray_t,r,temp_rec)){
            hit_anything = true;
            if(closest_so_far > temp_rec.t){
                closest_so_far = temp_rec.t;
                rec = temp_rec;
            }
        }
    }

    return hit_anything;
}

// Color of the skybox where the ray is pointing to
vec4 skybox_color_day(Ray r) {
    const vec3 sun_dir = vec3(-0.33, 0.67, -0.67);
    const vec4 sun_color = vec4(1.0);
    const float sun_size = 0.999;
    const float light_bleed = 0.0003;
    const vec4 horizon_color = vec4(0.231, 0.756, 0.945, 1.0);
    const vec4 zenith_color = vec4(1.0);

    vec3 dir_unit = normalize(r.dir);
    float a = 0.5 * (dir_unit.y + 1.0); 
    vec4 sky_gradient = mix(horizon_color, zenith_color, a);

    float sun_dot = dot(sun_dir, dir_unit);
    float sun_mask = smoothstep(sun_size - light_bleed, sun_size + light_bleed, sun_dot);

    return mix(sky_gradient, sun_color, sun_mask);
}

vec4 skybox_color_night(Ray r) {
    const vec3 moon_dir = normalize(vec3(0.33, 0.67, -0.67));
    const vec4 moon_color = vec4(0.9, 0.9, 0.8, 1.0); 
    const float moon_size = 0.999;
    const float light_bleed = 0.0003;
    const vec4 horizon_color = vec4(0.0);
    const vec4 zenith_color = vec4(0.005, 0.005, 0.005, 1.0); 

    vec3 dir_unit = normalize(r.dir);
    float a = 0.5 * (dir_unit.y + 1.0); 
    vec4 sky_gradient = mix(horizon_color, zenith_color, a);

    float moon_dot = dot(moon_dir, dir_unit);
    float moon_mask = smoothstep(moon_size - light_bleed, moon_size + light_bleed, moon_dot);

    return mix(sky_gradient, moon_color, moon_mask);
}


// Calculates the color of the ray by tracing it with the scene
vec4 ray_color(Ray r){
    vec4 incoming_light = vec4(0.0);
    vec4 ray_color = vec4(1.0); 
    
    for (int bounce = 0; bounce < max_bounces; bounce++) {
        Hit h;
        if (hit_scene(r, Interval(0.005, PINF), h)) {
            //return 0.5 * (vec4(h.normal,0.0)+vec4(1.0)); // Normal vector colors
            if(!scatter(h,r,ray_color,incoming_light)){
                // No scatering material
                break;
            }
        } else {
            incoming_light += skybox_color_night(r) * ray_color;
            break;
        }
    }
    
    return incoming_light;
}

// Generates a ray pointing to the pixel this thread is assign with a random half-pixel (square) offset
Ray get_ray(){
    vec2 pixelCoordsOffset = pixelCoords + sample_square();

    float ndcX = 2.0 * pixelCoordsOffset.x / imageSize.x - 1.0;
    float ndcY = 1.0 - 2.0 * pixelCoordsOffset.y / imageSize.y;

    vec3 rayDirCameraSpace = normalize(vec3(
        ndcX * aspectRatio * ubo.camera.tanHalfFOV,
        ndcY * ubo.camera.tanHalfFOV,
        -1.0
    ));

    vec3 rayDir = normalize(vec3(ubo.camera.viewInv * vec4(rayDirCameraSpace, 0.0)));

    Ray ray;
    ray.orig = ubo.camera.position;
    ray.dir = rayDir;

    return ray;
}



void main() {

    // RNG seed, will change after each generation of number
    seed = hash(uint(ubo.time)*1920) 
            ^ hash(ubo.frameCount)
            ^ hash(uint(pixelCoords.x + pixelCoords.y * 1920));
    /*hash(floatBitsToUint(ubo.camera.view[0][0])) 
          ^ hash(floatBitsToUint(ubo.camera.view[1][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[2][2])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][1])) 
          ^ hash(floatBitsToUint(ubo.camera.view[0][2])) 
    */

    vec4 color = vec4(0.0);
    Ray ray;

    for(int i = 0; i < rays_per_pixel; i++){
        ray = get_ray();
        color += ray_color(ray);
    }

    // Calculate color of pixel
    color = color/rays_per_pixel;
    //color = normalize(vec4(random(),random(),random(),0.0)); // Visual rng test
    color = vec4(pow(color.xyz, vec3(1.0/2.2)), 1.0);
    
    // Store color
    imageStore(outputImage, pixelCoords, color.zyxw);
}